# Event-Sourcing *meets* DDD Aggregates

## Creating an AggRoot
Aggregates are the center of your DomainAPI. Each API can source its aggregates differently, either from a traditional database or in some cases where it ,makes sense, using event sourcing and potentially running *without a database*

Often its hard to understand exactly how you may event source some object or run a system without a database.

Lets take a typrical document model, and add some event-sourcing godness
```c#
    public class DocumentModel
    {
        public string DocumentId { get; private set; }
        public string EnteredBy { get; private set; }
        public string Title { get; private set; }
        public string Name { get; private set; }
        public string Type { get; private set; }
        /// <summary>
        /// The list of roles with access to this document,
        /// </summary>
        public string[] Roles { get; private set; }
        public DateTime? CreationDate { get; private set; }
        public DateTime? LastUpdate { get; private set; }
        public bool? CanBeUsedExternally { get; private set; }
        public Guid? UserEnteredBy { get; private set; }
        public string Notes { get; private set; }

        public Document() { }
        public Document(string documentId, string name)
        {
            DocumentId = documentId;
            Name = name;
            Roles = new string[] { };
        }

        public void Upload(UserUploadeADocument @event)
        {            
            DocumentId = @event.DocumentId;
            UserEnteredBy = UserEnteredBy;
            EnteredBy = @event.UserName;
            CanBeUsedExternally = @event.IsExternallyVisible;
            Title = @event.Title;
            Name = @event.Name;
            Type = @event.Type;
            CreationDate = @event.Timestamp;
            LastUpdate = @event.Timestamp;
            Notes = @event.Notes;
        }               

        public void Update(UserUpdatedADocument @event)
        {
            DocumentId = @event.DocumentId;
            UserEnteredBy = UserEnteredBy;
            EnteredBy = @event.UserName;
            CanBeUsedExternally = @event.IsExternallyVisible;
            Title = @event.Title;
            Name = @event.Name;
            Type = @event.Type;
            LastUpdate = @event.LastUpdate;
            Notes = @event.Notes;
        } 
        

        public void AssignSecurityRule(DocumentSecurityRuleAdded @event)
        {
            Roles = Roles.Where(r => r != @event.Role).Concat(new[] {@event.Role}).ToArray();
        }

        public void RemoveSecurityRule(DocumentSecurityRuleAdded @event)
        {
            Roles = Roles.Where(r => r != @event.Role).ToArray();
        }

        //NOW: Lets sprinkle in some event-sourcing. When doing this, we relate back to the DomainAPI, its mostly boilerplate        
        public void Apply(UserUploadedADocument @event)
        {
            Upload(@event);
        }

        //just to reinforce the DDD idea, 
        //Even though a user may have "Clicked on a button" to "trigger the upload"
        //this process actually translated that technical domain to "Updating a document"
        public void Apply(UserUpdatedADocument @event)
        {
            Update(@event);
        }

        //instead of thinking in technical terms, we have adapted "permissions" to our domain
        public void Apply(DocumentSecurityRuleAdded @event)
        {
           AssignSecurityRule(@event);
        }


        public void Apply(DocumentSecurityRuleRemoved @event)
        {
            RemoveSecurityRule(@event);
        }
    }
```

To turn this into an aggreRoot, we implement the interface

```c#
    /// <summary>
    /// Represents an aggregate root event sourced data model
    /// </summary>
    public interface IAggRoot
    {
        /// <summary>
        /// The unique id of the aggregate
        /// </summary>
        string EId { get; set; }
        /// <summary>
        /// The unique id of the aggregate
        /// </summary>
        string Tenant { get; set; }
        /// <summary>
        /// Gets any events that have been generated by the aggregate from commands that have been executed against it
        /// </summary>
        /// <returns></returns>
        IEnumerable<IDomainEvent> GetUncommittedChanges();
        /// <summary>
        /// Re-hydrates an aggregate from its historical events
        /// </summary>
        /// <param name="history"></param>
        void LoadFromHistory(IEnumerable<IDomainEvent> history);
        /// <summary>
        /// Tells the aggregate that a series of events has been persisted to a reliable data store for later retreival,
        /// meaning it no longer needs to maintain them its in history
        /// </summary>
        /// <param name="changes"></param>
        void MarkChangesAsCommitted(params IDomainEvent[] changes);
        /// <summary>
        /// The version of the aggregate. This is not used yet but in the future it can be used to verify consistancy of 
        /// the aggregte before performing operations against it that require this 
        /// </summary>
        int Version { get; set; }

        void ApplyChange(dynamic @event);
    }
```

So we update our implementation with

```c#
public class DocumentModel : AggRoot //rxns provides a base implementation,
```

and now its event sourced.

## Persisting your AggRoots

The `ITenantModelRepository` is the RxnAPI abstraction that allows you to CRUD your Aggs with over time. You create them with the `ITenantModelFactory`

Use the `TapeArrayTenantModelRepository` to create an event sourced repository

>Related: [Recording and playing](playback.md) back your event streams

## Exposing your AggRoots with a DomainAPI

The `IDomainQueryMediator` is responsible for executing DomainAPI queries which are reffered to as `Lookups`. Likewise, the `IDomainCommandMediator` handles all `Command`s, which is the only the operation class that is *allowed* to mutate the Aggs state.

Clients always access these mediators via the `ICommandService`. This allows you to seperate the concern of transport form the API itself. Depending on the environment, the concrete implementation the container may produce you could be:

```c#
public interface ICommandService
{
    IObservable<DomainQueryResult<T>> Run<T>(IDomainQuery<T> query);
    IObservable<DomainCommandResult<T>> Run<T>(IDomainCommand<T> cmd);
    IObservable<object> Run(IServiceCommand cmd);
    IObservable<ICommandResult> Run(string cmd);
}
```

* `LocallyExecutingCommandService`  | Executes commands against the local RxnApp
* `CommandServiceCLient` | Executes commands via the [WebAPI](rxnhosts.md) host.  
* `RxnManagerCommandServiceClient` | Executes commands using the *RxnApps* `RxnManager` whos backing channel can be anything from an `eventbus` to a `webAPI`


